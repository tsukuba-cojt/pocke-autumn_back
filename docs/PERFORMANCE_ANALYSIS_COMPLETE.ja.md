# 完全パフォーマンス分析: Node.js vs Bun

## 概要

この包括的分析では、複数のテストシナリオ（ローカル開発、単発Dockerテスト、統計的バッチテスト）でNode.jsとBunの性能を比較します。結果は、異なる環境でのランタイム動作について重要な洞察を明らかにします。

## テスト方法論

### 実施されたテストシナリオ

1. **ローカル開発テスト** (2025-06-13)
   - 環境: ローカルサーバー（Node.js用tsx、Bun用bun）
   - 実行時間: 30秒間、5並行ユーザー
   - 目的: ベースライン性能比較

2. **単発Dockerコンテナテスト** (2025-06-16)
   - 環境: Dockerコンテナ（本番設定）
   - 実行時間: 30秒間、5並行ユーザー
   - 目的: コンテナ化影響評価

3. **統計的バッチテスト** (2025-06-16)
   - 環境: Dockerコンテナ、各10回実行
   - 実行時間: テスト1回あたり30秒間、5並行ユーザー
   - 目的: 統計的有意性と信頼性分析

### 技術設定

- **フレームワーク**: Hono（クリーンアーキテクチャ実装）
- **テストツール**: K6負荷テスト
- **テストエンドポイント**:
  - `GET /hello`（基本ヘルスチェック）
  - `GET /pokemon/1`（API統合）
  - `GET /pokemon/25`（追加検証）
- **成功基準**: リクエストの95%が500ms未満、エラー率0.1%未満

## 結果サマリー

### 1. ローカル開発性能

| 指標 | Node.js ローカル | Bun ローカル | Bunの優位性 |
|------|-----------------|-------------|-------------|
| **スループット** | 252.18 req/s | 262.99 req/s | **+4.3%** |
| **平均応答時間** | 19.77ms | 18.95ms | **+4.1%** |
| **95パーセンタイル** | 45.28ms | 43.60ms | **+3.7%** |
| **最大応答時間** | 1,313ms | 257ms | **+80.4%** |
| **成功率** | 100% | 100% | 完璧 |

**重要な発見**: Bunは一貫した改善を示し、特に最悪ケースシナリオで優秀。

### 2. 単発Dockerコンテナ性能

| 指標 | Node.js Docker | Bun Docker | 比較 |
|------|---------------|------------|------|
| **スループット** | 249.36 req/s | 249.57 req/s | **+0.1%** |
| **平均応答時間** | 19.93ms | 19.89ms | **+0.2%** |
| **95パーセンタイル** | 45.18ms | 44.10ms | **+2.4%** |
| **最大応答時間** | 1,366ms | 557ms | **+59.2%** |
| **成功率** | 100% | 100% | 完璧 |

**重要な発見**: ほぼ同一のスループットだが、Bunが優れた最悪ケース性能を維持。

### 3. 統計的バッチテスト（10回実行）

| 指標 | Node.js Docker | Bun Docker | 現実確認 |
|------|---------------|------------|----------|
| **スループット** | 251.6 ± 11.8 req/s | 225.4 ± 41.2 req/s | **-10.4%** |
| **平均応答時間** | 19.84 ± 1.01 ms | 23.23 ± 6.78 ms | **-17.1%** |
| **95パーセンタイル** | 45.08 ± 2.67 ms | 52.08 ± 16.06 ms | **-15.5%** |
| **一貫性** | 高い安定性 | 高い変動性 | **Node.jsの勝利** |

**重要な発見**: BunはDocker環境で大幅な性能変動を示す。

## 性能特性分析

### Node.js性能プロファイル

#### 強み

- **すべてのテストシナリオで例外的な一貫性**
- **低い変動性で予測可能な性能**（±11.8 req/s）
- **最小限のコンテナ化オーバーヘッドで成熟したDocker最適化**
- **信頼性の高い本番特性**

#### 性能パターン

- ローカル: 堅実なベースライン性能
- Docker単発: 最小限の性能劣化
- Dockerバッチ: 高い一貫性のある結果

### Bun性能プロファイル

#### 強み

- **最適条件での優れたピーク性能**
- **安定環境での優秀な最悪ケース処理**
- **優れたローカル開発性能**

#### 弱み

- **コンテナ化環境での高い性能変動**
- **予測不可能なDocker性能**（115-254 req/sの範囲）
- **特定条件下での大幅な劣化の可能性**

#### 性能パターン

- ローカル: Node.jsに一貫して優位
- Docker単発: Node.jsと同等
- Dockerバッチ: 高い変動性、しばしば劣位

## 環境別洞察

### ローカル開発環境

**勝者: Bun**

- 4.3%高いスループット
- 4.1%高速な平均応答時間
- 80%優れた最悪ケース性能
- 優秀な開発者体験

### Docker本番環境

**勝者: Node.js**

- 高い一貫性のある性能
- 予測可能なリソース利用率
- 低い運用リスク
- 本番実証済みの信頼性

## 統計的有意性

### 信頼区間（95%）

**ローカル環境:**

- Node.js: 一貫したベースライン
- Bun: 一貫して4-5%優位

**Docker環境（バッチテスト）:**

- Node.js: 251.6 ± 8.4 req/s（CI: 243.2-260.0）
- Bun: 225.4 ± 29.3 req/s（CI: 196.1-254.7）

**解釈**: バッチテストの重複しない信頼区間は、統計的に有意な性能差を示している。

## 根本原因分析

### 単発テストが誤解を招く理由

単発測定は最適条件を捉えるが、以下を見逃す:

- 性能変動パターン
- 繰り返しストレス下での信頼性
- リソース競合効果
- コンテナ起動の不一致

### BunのDocker課題

1. **コンテナ最適化のギャップ**: Node.js Dockerイメージがより成熟
2. **リソース感度**: Bunがコンテナリソース割り当てにより敏感
3. **起動変動**: 一貫性のないコンテナ初期化時間
4. **ネットワークスタックの違い**: コンテナ化環境での異なるネットワーク動作

## 本番デプロイメント推奨事項

### 本番使用向け

#### Node.jsを選ぶべき場合

- **信頼性が重要**（金融サービス、ヘルスケア）
- **一貫した性能**が必要
- **Docker/Kubernetesデプロイメント**が計画されている
- **運用の簡潔性**が好まれる

#### Bunを選ぶべき場合

- **ピーク性能**が一貫性より重要
- **ローカル開発**速度が優先される
- **コンテナ最適化に投資**する意思がある
- **性能監視**インフラが利用可能

### リスク評価

| ランタイム | 信頼性リスク | 性能リスク | 運用リスク |
|-----------|-------------|-----------|-----------|
| **Node.js** | 低 | 低 | 低 |
| **Bun** | 中 | 中-高 | 中 |

## 開発ワークフロー推奨事項

### 最適戦略

1. **開発**: 優秀なローカル性能のためBunを使用
2. **テスト**: CI/CDパイプラインに両ランタイムを含める
3. **ステージング**: 本番パリティのためNode.jsでテスト
4. **本番**: 信頼性のためNode.jsをデプロイ

### 性能監視

Bunデプロイメント向け:

- 包括的な性能監視を実装
- 性能劣化のアラートを設定
- 定期的な性能回帰テスト
- コンテナリソース最適化

## 結論

この包括的分析は、微妙な性能の状況を明らかにします:

### 主要な発見

1. **環境が重要**: 性能特性はローカルとコンテナ化環境で大幅に変化
2. **単発テストは欺く**: バッチテストが真の性能ストーリーを明らかにする
3. **一貫性の勝利**: 本番では、予測可能な性能がピーク性能を上回ることが多い
4. **文脈依存の選択**: 「より良い」ランタイムは、デプロイメント文脈に完全に依存

### 最終推奨事項

**ほとんどの本番シナリオ向け**: **Node.js**が性能、信頼性、運用の簡潔性の最良のバランスを提供。

**開発向け**: **Bun**が優秀な開発者体験と性能を提供。

**高性能シナリオ向け**: 広範囲な監視とコンテナ最適化でBunを検討。

Node.jsとBunの選択は、ピーク性能指標だけでなく、信頼性、性能一貫性、運用複雑性の特定要件に基づくべきです。

---

## テストデータアーカイブ

- **ローカルテスト**: `performance-results/node_20250613_145323.json`, `performance-results/bun_20250613_145323.json`
- **Docker単発**: `performance-results/node_20250616_101423.json`, `performance-results/bun-docker_*.json`
- **バッチテスト**: `performance-results/batch-20250616_102415/`（20テストファイル + サマリー）

*HonoベースのクリーンアーキテクチャアプリケーションでK6負荷テストフレームワークを使用して分析を実施。*
